"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNetworkMatch = isNetworkMatch;
exports.isValidExtPubKey = isValidExtPubKey;
exports.isValidAddress = isValidAddress;
exports.isValidPurpose = isValidPurpose;
exports.isValidIndex = isValidIndex;
exports.isValidPathSegment = isValidPathSegment;

var _unchainedBitcoin = require("unchained-bitcoin");

var _metadata = require("./metadata");

var _conversion = require("./conversion");

var _purpose = require("./purpose");

var _utils = require("./utils");

var _constants = require("./constants");

/**
 * This module contains methods to validate extended public keys and BIP32
 * derivation path segments.
 *
 * @module validation
 */

/**
 * Returns true if the given `extPubKey` matches the given `network`, false otherwise.
 *
 * @param  {string} extPubKey - the extended public key
 * @param  {NETWORK} network - the network to check against
 *
 * @returns {boolean}
 */
function isNetworkMatch(extPubKey, network) {
  return extPubKey && (0, _metadata.getNetworkFromExtPubKey)(extPubKey) === network;
}
/**
 * Returns true if the given `extPubKey` is valid for the given `network`,
 * false otherwise.
 *
 * @param  {string} extPubKey - the extended public key
 * @param  {NETWORK} network - the network to check against
 *
 * @returns {boolean}
 */


function isValidExtPubKey(extPubKey, network) {
  if (!isNetworkMatch(extPubKey, network)) {
    return false;
  }

  try {
    var convertedExtPubKey = (0, _conversion.convertToXPUB)(extPubKey, network); // validateExtendedPublicKey expects "xpub..." or "tpub..."

    return (0, _unchainedBitcoin.validateExtendedPublicKey)(convertedExtPubKey, network) === "";
  } catch (error) {
    return false;
  }
}
/**
 * Returns true if the given bitcoin `address` is valid for the given
 * `network`, false otherwise.
 *
 * @param  {string} address - the given bitcoin address
 * @param  {NETWORK} network - the network to check against
 *
 * @returns {boolean}
 */


function isValidAddress(address, network) {
  return (0, _unchainedBitcoin.validateAddress)(address, network) === "";
}
/**
 * Returns true if the given derivation purpose is valid, false otherwise.
 *
 * @param  {module:purpose~Purpose} purpose - the derivation purpose
 *
 * @returns {boolean}
 */


function isValidPurpose(purpose) {
  switch (purpose) {
    case _purpose.Purpose.P2PKH:
    case _purpose.Purpose.P2SH:
    case _purpose.Purpose.P2WPKH:
      return true;

    default:
      return false;
  }
}
/**
 * Returns true if the given index is valid, false otherwise.
 *
 * @param  {number} index - the BIP32 index to check
 *
 * @returns {boolean}
 */


function isValidIndex(index) {
  var indexString = (0, _utils.harden)(String(index));

  try {
    return (0, _unchainedBitcoin.validateBIP32Index)(indexString, {
      mode: "hardened"
    }) === "";
  } catch (error) {
    return false;
  }
}
/**
 * Returns true if the path segment is hardened, false otherwise.
 *
 * @param  {string} segment - the path segment to check
 *
 * @returns {boolean}
 */


function isHardened(segment) {
  return segment.includes(_constants.APOSTROPHE);
}
/**
 * Returns true if the given BIP32 path segment is valid, false otherwise.
 *
 * @param  {string} segment - the path segment to check
 *
 * @returns {boolean}
 */


function isValidPathSegment(segment) {
  var unhardened = segment;

  if (isHardened(segment)) {
    unhardened = segment.slice(0, -1);
  }

  switch (unhardened) {
    case _constants.COIN_PREFIX:
      return true;

    case _purpose.Purpose.P2PKH:
    case _purpose.Purpose.P2SH:
    case _purpose.Purpose.P2WPKH:
      return true;

    default:
      return isValidIndex(unhardened);
  }
}