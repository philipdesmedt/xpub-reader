"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateFeeRate = validateFeeRate;
exports.validateFee = validateFee;
exports.estimateMultisigTransactionFeeRate = estimateMultisigTransactionFeeRate;
exports.estimateMultisigTransactionFee = estimateMultisigTransactionFee;

var _bignumber = _interopRequireDefault(require("bignumber.js"));

var _p2sh = require("./p2sh");

var _p2sh_p2wsh = require("./p2sh_p2wsh");

var _p2wsh = require("./p2wsh");

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** 
 * This module provides functions for calculating & validating
 * transaction fees.
 * 
 * @module fees
 */

/**
 * Maxmium acceptable transaction fee rate in Satoshis/vbyte.
 *
 * @constant
 * @type {BigNumber}
 * @default 1000 Satoshis/vbyte
 * 
 */
var MAX_FEE_RATE_SATS_PER_VBYTE = (0, _bignumber.default)(1000); // 1000 Sats/vbyte

/**
 * Maxmium acceptable transaction fee in Satoshis.
 *
 * @constant
 * @type {BigNumber}
 * @default 2500000 Satoshis (=0.025 BTC)
 */

var MAX_FEE_SATS = (0, _bignumber.default)(2500000); // ~ 0.025 BTC ~ $250 if 1 BTC = $10k

/**
 * Validate the given transaction fee rate (in Satoshis/vbyte).
 *
 * - Must be a parseable as a number.
 *
 * - Cannot be negative (zero is OK).
 * 
 * - Cannot be greater than the limit set by
 *   `MAX_FEE_RATE_SATS_PER_VBYTE`.
 * 
 * @param {string|number|BigNumber} feeRateSatsPerVbyte - the fee rate in Satoshis/vbyte
 * @returns {string} empty if valid or corresponding validation message if not
 * @example
 * import {validateFeeRate} from "unchained-bitcoin";
 * console.log(validateFeeRate(-1)); // "Fee rate must be positive."
 * console.log(validateFeeRate(10000)); // "Fee rate is too high."
 * console.log(validateFeeRate(250)); // ""
 */

function validateFeeRate(feeRateSatsPerVbyte) {
  var fr;

  try {
    fr = (0, _bignumber.default)(feeRateSatsPerVbyte);
  } catch (e) {
    return "Invalid fee rate.";
  }

  if (!fr.isFinite()) {
    return "Invalid fee rate.";
  }

  if (fr.isLessThan(_utils.ZERO)) {
    return "Fee rate cannot be negative.";
  }

  if (fr.isGreaterThan(MAX_FEE_RATE_SATS_PER_VBYTE)) {
    return "Fee rate is too high.";
  }

  return '';
}
/**
 * Validate the given transaction fee (in Satoshis).
 *
 * - Must be a parseable as a number.
 *
 * - Cannot be negative (zero is OK).
 *
 * - Cannot exceed the total input amount.
 *
 * - Cannot be higher than the limit set by `MAX_FEE_SATS`.
 * 
 * @param {string|number|BigNumber} feeSats - fee in Satoshis
 * @param {string|number|BigNumber} inputsTotalSats - total input amount in Satoshis
 * @returns {string} empty if valid or corresponding validation message if not
 * @example
 * import {validateFee} from "unchained-bitcoin";
 * console.log(validateFee(3000000, 10000000)) // "Fee is too high."
 * console.log(validateFee(30000, 20000)) // "Fee is too high."
 * console.log(validateFee(-30000)) // "Fee cannot be negative."
 * console.log(validateFee(30000, 10000000)) // ""
 */


function validateFee(feeSats, inputsTotalSats) {
  var fs, its;

  try {
    fs = (0, _bignumber.default)(feeSats);
  } catch (e) {
    return "Invalid fee.";
  }

  if (!fs.isFinite()) {
    return "Invalid fee.";
  }

  try {
    its = (0, _bignumber.default)(inputsTotalSats);
  } catch (e) {
    return "Invalid total input amount.";
  }

  if (!its.isFinite()) {
    return "Invalid total input amount.";
  }

  if (fs.isLessThan(_utils.ZERO)) {
    return "Fee cannot be negative.";
  }

  if (its.isLessThanOrEqualTo(_utils.ZERO)) {
    return "Total input amount must be positive.";
  }

  if (fs.isGreaterThan(its)) {
    return "Fee is too high.";
  }

  if (fs.isGreaterThan(MAX_FEE_SATS)) {
    return "Fee is too high.";
  }

  return '';
}
/**
 * Estimate transaction fee rate based on actual fee and address type, number of inputs and number of outputs.
 * 
 * @param {Object} config - configuration for the calculation
 * @param {module:multisig.MULTISIG_ADDRESS_TYPES} config.addressType - address type used for estimation
 * @param {number} config.numInputs - number of inputs used in calculation
 * @param {number} config.numOutputs - number of outputs used in calculation
 * @param {number} config.m - number of required signers for the quorum
 * @param {number} config.n - number of total signers for the quorum
 * @param {BigNumber} config.feesInSatoshis - total transaction fee in satoshis
 * @example 
 * import {estimateMultisigP2WSHTransactionFeeRate} from "unchained-bitcoin";
 * // get the fee rate a P2WSH multisig transaction with 2 inputs and 3 outputs with a known fee of 7060
 * const feerate = estimateMultisigTransactionFeeRate({
 *   addressType: P2WSH, 
 *   numInputs: 2, 
 *   numOutputs: 3, 
 *   m: 2,
 *   n: 3,
 *   feesInSatoshis: 7060
 * });
 * 
 * 
 * @returns {string} estimated fee rate
 */


function estimateMultisigTransactionFeeRate(config) {
  return (0, _bignumber.default)(config.feesInSatoshis).dividedBy(estimateMultisigTransactionVSize(config));
}
/**
 * Estimate transaction fee based on fee rate, address type, number of inputs and outputs.
 * @param {Object} config - configuration for the calculation
 * @param {module:multisig.MULTISIG_ADDRESS_TYPES} config.addressType - address type used for estimation
 * @param {number} config.numInputs - number of inputs used in calculation
 * @param {number} config.numOutputs - number of outputs used in calculation
 * @param {number} config.m - number of required signers for the quorum
 * @param {number} config.n - number of total signers for the quorum
 * @param {string} config.feesPerByteInSatoshis - satoshis per byte fee rate
 * @example
 * // get fee for P2SH multisig transaction with 2 inputs and 3 outputs at 10 satoshis per byte
 * import {estimateMultisigP2WSHTransactionFee} from "unchained-bitcoin";
 * const fee = estimateMultisigTransactionFee({
 *   addressType: P2SH, 
 *   numInputs: 2, 
 *   numOutputs: 3, 
 *   m: 2,
 *   n: 3,
 *   feesPerByteInSatoshis: 10
 * });
 * @returns {number} estimated transaction fee
 */


function estimateMultisigTransactionFee(config) {
  return (0, _bignumber.default)(config.feesPerByteInSatoshis).multipliedBy(estimateMultisigTransactionVSize(config));
}

function estimateMultisigTransactionVSize(config) {
  switch (config.addressType) {
    case _p2sh.P2SH:
      return (0, _p2sh.estimateMultisigP2SHTransactionVSize)(config);

    case _p2sh_p2wsh.P2SH_P2WSH:
      return (0, _p2sh_p2wsh.estimateMultisigP2SH_P2WSHTransactionVSize)(config);

    case _p2wsh.P2WSH:
      return (0, _p2wsh.estimateMultisigP2WSHTransactionVSize)(config);

    default:
      return null;
  }
}