"use strict";

var _inputs = require("./inputs");

var VALID_TXID = "65e7ef764030dabfb46e3ae1c357b0666d0dda722c9809fb73245d6d68665284";
describe("inputs", function () {
  describe("sortInputs", function () {
    it("sorts inputs in ascending lexicographic order by txid and index", function () {
      var unsortedInputs = [{
        txid: "def123",
        index: 0
      }, {
        txid: "0123",
        index: 2
      }, {
        txid: "abc123",
        index: 1
      }, {
        txid: "abc123",
        index: 0
      }];
      var sortedInputs = (0, _inputs.sortInputs)(unsortedInputs);
      expect(sortedInputs[0].txid).toEqual("0123");
      expect(sortedInputs[0].index).toEqual(2);
      expect(sortedInputs[1].txid).toEqual("abc123");
      expect(sortedInputs[1].index).toEqual(0);
      expect(sortedInputs[2].txid).toEqual("abc123");
      expect(sortedInputs[2].index).toEqual(1);
      expect(sortedInputs[3].txid).toEqual("def123");
      expect(sortedInputs[3].index).toEqual(0);
    });
  });
  describe("validateMultisigInputs", function () {
    it("should return an error message if one of the inputs is invalid", function () {
      expect((0, _inputs.validateMultisigInputs)([{
        txid: VALID_TXID,
        index: 0
      }, {
        txid: VALID_TXID,
        index: 1,
        multisig: true
      }])).toMatch(/not have a multisig.+property/i);
    });
    it("should return an error message the UTXOs are duplicative", function () {
      expect((0, _inputs.validateMultisigInputs)([{
        txid: VALID_TXID,
        index: 0,
        multisig: true
      }, {
        txid: VALID_TXID,
        index: 0,
        multisig: true
      }])).toMatch(/duplicate input/i);
    });
    it("should return an empty string if all inputs are valid", function () {
      expect((0, _inputs.validateMultisigInputs)([{
        txid: VALID_TXID,
        index: 0,
        multisig: true
      }, {
        txid: VALID_TXID,
        index: 1,
        multisig: true
      }])).toEqual("");
    });
  });
  describe("validateMultisigInput", function () {
    it("should return an error message for a missing txid", function () {
      expect((0, _inputs.validateMultisigInput)({
        index: 0,
        multisig: true
      })).toMatch(/does not have.+txid/i);
    });
    it("should return an error message for an invalid txid", function () {
      expect((0, _inputs.validateMultisigInput)({
        index: 0,
        multisig: true,
        txid: "hi there"
      })).toMatch(/txid is invalid/i);
    });
    it("should return an error message for a missing index", function () {
      expect((0, _inputs.validateMultisigInput)({
        txid: VALID_TXID,
        multisig: true
      })).toMatch(/does not have.+index/i);
    });
    it("should return an error message for an invalid index", function () {
      expect((0, _inputs.validateMultisigInput)({
        txid: VALID_TXID,
        index: -1,
        multisig: true
      })).toMatch(/index cannot be negative/i);
    });
    it("should return an error message for a missing multisig", function () {
      expect((0, _inputs.validateMultisigInput)({
        txid: VALID_TXID,
        index: 0
      })).toMatch(/does not have.+multisig/i);
    });
  });
  describe("validateTransactionID", function () {
    it("should return an error message for invalid TXIDs", function () {
      expect((0, _inputs.validateTransactionID)()).toMatch(/cannot be blank/i);
      expect((0, _inputs.validateTransactionID)("")).toMatch(/cannot be blank/i);
      expect((0, _inputs.validateTransactionID)("hi there")).toMatch(/invalid hex/i);
      expect((0, _inputs.validateTransactionID)("deadbeef")).toMatch(/invalid.+64/);
    });
    it("should return an empty string for a valid TXID", function () {
      expect((0, _inputs.validateTransactionID)(VALID_TXID)).toEqual("");
    });
  });
  describe("validateTransactionIndex", function () {
    it("should return an error message for invalid TXIDs", function () {
      expect((0, _inputs.validateTransactionIndex)()).toMatch(/cannot be blank/i);
      expect((0, _inputs.validateTransactionIndex)("")).toMatch(/cannot be blank/i);
      expect((0, _inputs.validateTransactionIndex)("foo")).toMatch(/index is invalid/i);
      expect((0, _inputs.validateTransactionIndex)("-1")).toMatch(/cannot be negative/i);
    });
    it("should return an empty string for a valid index", function () {
      expect((0, _inputs.validateTransactionIndex)(1)).toEqual("");
      expect((0, _inputs.validateTransactionIndex)(0)).toEqual("");
    });
  });
});