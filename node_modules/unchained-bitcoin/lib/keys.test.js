"use strict";

require("core-js/modules/es6.regexp.to-string");

require("core-js/modules/web.dom.iterable");

require("core-js/modules/es6.array.iterator");

require("core-js/modules/es6.object.to-string");

require("core-js/modules/es6.object.keys");

var _bs58check = _interopRequireDefault(require("bs58check"));

var _bs = _interopRequireDefault(require("bs58"));

var _keys = require("./keys");

var _networks = require("./networks");

var _fixtures = require("./fixtures");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NODES = _fixtures.TEST_FIXTURES.nodes;
var extendedPubKeyNode = _fixtures.TEST_FIXTURES.nodes["m/45'/0'/0'"];
describe("keys", function () {
  describe("validateExtendedPublicKey", function () {
    var validXpub = "xpub6CCHViYn5VzKFqrKjAzSSqP8XXSU5fEC6ZYSncX5pvSKoRLrPDcF8cEaZkrQvvnuwRUXeKVjoGmAqvbwVkNBFLaRiqcdVhWPyuShUrbcZsv";
    var validTpub = "tpubDCZv1xNTnmwmXe3BBMyXekiVreY853jFeC8k9AaEAqCDYi1ZTSTLH3uQonwCTRk9jL1SFu1cLNbDY76YtcDR8n2inSMwBEAdZs37EpYS9px";
    it("returns an error message on an empty value", function () {
      expect((0, _keys.validateExtendedPublicKey)(undefined, _networks.TESTNET)).toMatch(/cannot be blank/i);
      expect((0, _keys.validateExtendedPublicKey)("", _networks.TESTNET)).toMatch(/cannot be blank/i);
      expect((0, _keys.validateExtendedPublicKey)(null, _networks.TESTNET)).toMatch(/cannot be blank/i);
    });
    it("returns an error message when the prefix does not match the network", function () {
      expect((0, _keys.validateExtendedPublicKey)("foo", _networks.TESTNET)).toMatch(/must begin with/i);
      expect((0, _keys.validateExtendedPublicKey)("tpub", _networks.MAINNET)).toMatch(/must begin with/i);
      expect((0, _keys.validateExtendedPublicKey)(validTpub, _networks.MAINNET)).toMatch(/must begin with/i);
      expect((0, _keys.validateExtendedPublicKey)(validXpub, _networks.TESTNET)).toMatch(/must begin with/i);
    });
    it("returns an error message when the value is too short", function () {
      expect((0, _keys.validateExtendedPublicKey)("tpub123", _networks.TESTNET)).toMatch(/is too short/i);
      expect((0, _keys.validateExtendedPublicKey)("xpub123", _networks.MAINNET)).toMatch(/is too short/i);
    });
    it("returns an error message when the value is too short", function () {
      expect((0, _keys.validateExtendedPublicKey)("tpub123", _networks.TESTNET)).toMatch(/is too short/i);
      expect((0, _keys.validateExtendedPublicKey)("xpub123", _networks.MAINNET)).toMatch(/is too short/i);
    });
    it("returns an error message when the value is not valid", function () {
      // they both have 'n' in them
      expect((0, _keys.validateExtendedPublicKey)(validTpub.replace("n", "p"), _networks.TESTNET)).toMatch(/invalid/i);
      expect((0, _keys.validateExtendedPublicKey)(validXpub.replace("n", "p"), _networks.MAINNET)).toMatch(/invalid/i);
    });
    it("returns an empty string when the value is valid", function () {
      expect((0, _keys.validateExtendedPublicKey)(validTpub, _networks.TESTNET)).toBe("");
      expect((0, _keys.validateExtendedPublicKey)(validXpub, _networks.MAINNET)).toBe("");
    });
  });
  describe("validatePublicKey", function () {
    it("returns an error message on an empty value", function () {
      expect((0, _keys.validatePublicKey)(undefined)).toMatch(/cannot be blank/i);
      expect((0, _keys.validatePublicKey)("")).toMatch(/cannot be blank/i);
      expect((0, _keys.validatePublicKey)(null)).toMatch(/cannot be blank/i);
    });
    it("returns an error message on a non-hex value", function () {
      expect((0, _keys.validatePublicKey)("zzzz")).toMatch(/invalid hex/i);
    });
    it("returns an error message on an invalid value", function () {
      expect((0, _keys.validatePublicKey)("deadbeef")).toMatch(/invalid public key/i);
    });
    it("returns an empty string when the value is a valid compressed public key", function () {
      expect((0, _keys.validatePublicKey)("03b32dc780fba98db25b4b72cf2b69da228f5e10ca6aa8f46eabe7f9fe22c994ee")).toBe("");
    });
    it("returns an empty string when the value is a valid uncompressed public key", function () {
      expect((0, _keys.validatePublicKey)("04b32dc780fba98db25b4b72cf2b69da228f5e10ca6aa8f46eabe7f9fe22c994ee6e43c09d025c2ad322382347ec0f69b4e78d8e23c8ff9aa0dd0cb93665ae83d5")).toBe("");
    });
  });
  describe("compressPublicKey", function () {
    it("compresses public keys", function () {
      expect((0, _keys.compressPublicKey)("04b32dc780fba98db25b4b72cf2b69da228f5e10ca6aa8f46eabe7f9fe22c994ee6e43c09d025c2ad322382347ec0f69b4e78d8e23c8ff9aa0dd0cb93665ae83d5")).toBe("03b32dc780fba98db25b4b72cf2b69da228f5e10ca6aa8f46eabe7f9fe22c994ee");
      expect((0, _keys.compressPublicKey)("04f7946511e5f5c2697ed1a6c7f1fb7cfa6c03c74ac123b3d2d0c19ad25899baa6bd72af01ea2a58460fe34c2a2d48527f91da977a45a224f50028d937feb68660")).toBe("02f7946511e5f5c2697ed1a6c7f1fb7cfa6c03c74ac123b3d2d0c19ad25899baa6");
      expect((0, _keys.compressPublicKey)("04d87003b52cc497a6ca9a72fd610bcbfb2fe1430ffc4c9d89c2b25b501e04d677ee43c602a902993757d479d89b004f70a944de6db953594be98f397921b20162")).toBe("02d87003b52cc497a6ca9a72fd610bcbfb2fe1430ffc4c9d89c2b25b501e04d677");
      expect((0, _keys.compressPublicKey)("040354bd30fed4d431ee2acb51391128c72af8ee2bec8a303d977a40c85ba82e7b0456f8717352c5cb95fef87671109a66243e0b6d4917b3c33eb6aa5f33e5c09d")).toBe("030354bd30fed4d431ee2acb51391128c72af8ee2bec8a303d977a40c85ba82e7b");
    });
  });
  describe("deriveChildPublicKey", function () {
    it("derives child public keys for unhardened paths on mainnet", function () {
      expect((0, _keys.deriveChildPublicKey)(NODES["m/45'/0'/0'"].xpub, "m/0/0", _networks.MAINNET)).toBe(NODES["m/45'/0'/0'/0/0"].pub);
      expect((0, _keys.deriveChildPublicKey)(NODES["m/45'/0'/0'"].xpub, "0/0", _networks.MAINNET)).toBe(NODES["m/45'/0'/0'/0/0"].pub);
      expect((0, _keys.deriveChildPublicKey)(NODES["m/45'/0'/4'"].xpub, "m/0/0", _networks.MAINNET)).toBe(NODES["m/45'/0'/4'/0/0"].pub);
      expect((0, _keys.deriveChildPublicKey)(NODES["m/45'/0'/4'"].xpub, "0/0", _networks.MAINNET)).toBe(NODES["m/45'/0'/4'/0/0"].pub);
      expect((0, _keys.deriveChildPublicKey)(NODES["m/45'/0'/4'"].xpub, "m/6/2", _networks.MAINNET)).toBe(NODES["m/45'/0'/4'/6/2"].pub);
      expect((0, _keys.deriveChildPublicKey)(NODES["m/45'/0'/4'"].xpub, "6/2", _networks.MAINNET)).toBe(NODES["m/45'/0'/4'/6/2"].pub);
    });
    it("derives child public keys for unhardened paths on testnet", function () {
      expect((0, _keys.deriveChildPublicKey)(NODES["m/45'/0'/0'"].tpub, "m/0/0", _networks.TESTNET)).toBe(NODES["m/45'/0'/0'/0/0"].pub);
      expect((0, _keys.deriveChildPublicKey)(NODES["m/45'/0'/0'"].tpub, "0/0", _networks.TESTNET)).toBe(NODES["m/45'/0'/0'/0/0"].pub);
      expect((0, _keys.deriveChildPublicKey)(NODES["m/45'/0'/4'"].tpub, "m/0/0", _networks.TESTNET)).toBe(NODES["m/45'/0'/4'/0/0"].pub);
      expect((0, _keys.deriveChildPublicKey)(NODES["m/45'/0'/4'"].tpub, "0/0", _networks.TESTNET)).toBe(NODES["m/45'/0'/4'/0/0"].pub);
      expect((0, _keys.deriveChildPublicKey)(NODES["m/45'/0'/4'"].tpub, "m/6/2", _networks.TESTNET)).toBe(NODES["m/45'/0'/4'/6/2"].pub);
      expect((0, _keys.deriveChildPublicKey)(NODES["m/45'/0'/4'"].tpub, "6/2", _networks.TESTNET)).toBe(NODES["m/45'/0'/4'/6/2"].pub);
    });
    it("throws an error when asked to derive down a hardened path", function () {
      expect(function () {
        (0, _keys.deriveChildPublicKey)(NODES["m/45'/0'/4'"].xpub, "m/99'", _networks.MAINNET);
      }).toThrow(/missing private key/i);
      expect(function () {
        (0, _keys.deriveChildPublicKey)(NODES["m/45'/0'/4'"].xpub, "m/99'/0/0", _networks.MAINNET);
      }).toThrow(/missing private key/i);
    });
    it("throws an error when passed a mismatch extended public key and network", function () {
      expect(function () {
        (0, _keys.deriveChildPublicKey)(NODES["m/45'/0'/0'"].xpub, "m/0/0", _networks.TESTNET);
      }).toThrow(/invalid network/i);
      expect(function () {
        (0, _keys.deriveChildPublicKey)(NODES["m/45'/0'/0'"].tpub, "m/0/0", _networks.MAINNET);
      }).toThrow(/invalid network/i);
    });
  });
  describe("deriveChildExtendedPublicKey", function () {
    it("derives child extended public keys for unhardened paths on mainnet", function () {
      expect((0, _keys.deriveChildExtendedPublicKey)(NODES["m/45'/0'/0'"].xpub, "m/0/0", _networks.MAINNET)).toBe(NODES["m/45'/0'/0'/0/0"].xpub);
      expect((0, _keys.deriveChildExtendedPublicKey)(NODES["m/45'/0'/0'"].xpub, "0/0", _networks.MAINNET)).toBe(NODES["m/45'/0'/0'/0/0"].xpub);
      expect((0, _keys.deriveChildExtendedPublicKey)(NODES["m/45'/0'/4'"].xpub, "m/0/0", _networks.MAINNET)).toBe(NODES["m/45'/0'/4'/0/0"].xpub);
      expect((0, _keys.deriveChildExtendedPublicKey)(NODES["m/45'/0'/4'"].xpub, "0/0", _networks.MAINNET)).toBe(NODES["m/45'/0'/4'/0/0"].xpub);
      expect((0, _keys.deriveChildExtendedPublicKey)(NODES["m/45'/0'/4'"].xpub, "m/6/2", _networks.MAINNET)).toBe(NODES["m/45'/0'/4'/6/2"].xpub);
      expect((0, _keys.deriveChildExtendedPublicKey)(NODES["m/45'/0'/4'"].xpub, "6/2", _networks.MAINNET)).toBe(NODES["m/45'/0'/4'/6/2"].xpub);
    });
    it("derives child extended public keys for unhardened paths on testnet", function () {
      expect((0, _keys.deriveChildExtendedPublicKey)(NODES["m/45'/0'/0'"].tpub, "m/0/0", _networks.TESTNET)).toBe(NODES["m/45'/0'/0'/0/0"].tpub);
      expect((0, _keys.deriveChildExtendedPublicKey)(NODES["m/45'/0'/0'"].tpub, "0/0", _networks.TESTNET)).toBe(NODES["m/45'/0'/0'/0/0"].tpub);
      expect((0, _keys.deriveChildExtendedPublicKey)(NODES["m/45'/0'/4'"].tpub, "m/0/0", _networks.TESTNET)).toBe(NODES["m/45'/0'/4'/0/0"].tpub);
      expect((0, _keys.deriveChildExtendedPublicKey)(NODES["m/45'/0'/4'"].tpub, "0/0", _networks.TESTNET)).toBe(NODES["m/45'/0'/4'/0/0"].tpub);
      expect((0, _keys.deriveChildExtendedPublicKey)(NODES["m/45'/0'/4'"].tpub, "m/6/2", _networks.TESTNET)).toBe(NODES["m/45'/0'/4'/6/2"].tpub);
      expect((0, _keys.deriveChildExtendedPublicKey)(NODES["m/45'/0'/4'"].tpub, "6/2", _networks.TESTNET)).toBe(NODES["m/45'/0'/4'/6/2"].tpub);
    });
    it("throws an error when asked to derive down a hardened path", function () {
      expect(function () {
        (0, _keys.deriveChildExtendedPublicKey)(NODES["m/45'/0'/4'"].xpub, "m/99'", _networks.MAINNET);
      }).toThrow(/missing private key/i);
      expect(function () {
        (0, _keys.deriveChildExtendedPublicKey)(NODES["m/45'/0'/4'"].xpub, "m/99'/0/0", _networks.MAINNET);
      }).toThrow(/missing private key/i);
    });
    it("throws an error when passed a mismatch extended public key and network", function () {
      expect(function () {
        (0, _keys.deriveChildExtendedPublicKey)(NODES["m/45'/0'/0'"].xpub, "m/0/0", _networks.TESTNET);
      }).toThrow(/invalid network/i);
      expect(function () {
        (0, _keys.deriveChildExtendedPublicKey)(NODES["m/45'/0'/0'"].tpub, "m/0/0", _networks.MAINNET);
      }).toThrow(/invalid network/i);
    });
  });
  describe("validatePrefix", function () {
    it("should return null if valid or throw otherwise", function () {
      Object.keys(_keys.EXTENDED_PUBLIC_KEY_VERSIONS).forEach(function (prefix) {
        expect((0, _keys.validatePrefix)(prefix)).toBe(null);
      });

      function invalidPrefix() {
        (0, _keys.validatePrefix)("jpub");
      }

      expect(invalidPrefix).toThrow();
    });
  });
  describe("Test convertExtendedPublicKey", function () {
    Object.keys(_keys.EXTENDED_PUBLIC_KEY_VERSIONS).forEach(function (convertTo) {
      describe("Test converting to ".concat(convertTo), function () {
        Object.keys(_keys.EXTENDED_PUBLIC_KEY_VERSIONS).forEach(function (convertFrom) {
          if (convertFrom === convertTo || !extendedPubKeyNode[convertFrom] || !extendedPubKeyNode[convertTo]) {
            return;
          }

          it("should properly convert extended public key from ".concat(convertFrom, " to ").concat(convertTo), function () {
            var converted = (0, _keys.convertExtendedPublicKey)(extendedPubKeyNode[convertFrom], convertTo);
            expect(converted).toBe(extendedPubKeyNode[convertTo]);
          });
        });
      });
    });
  });
  describe("isKeyCompressed", function () {
    it("checks if a key is compressed or uncompressed", function () {
      var uncompressedPubkey = "0487cb4929c287665fbda011b1afbebb0e691a5ee11ee9a561fcd6adba266afe03f7c55f784242305cfd8252076d038b0f3c92836754308d06b097d11e37bc0907";
      expect((0, _keys.isKeyCompressed)(uncompressedPubkey)).toBeFalsy();
      expect((0, _keys.isKeyCompressed)((0, _keys.compressPublicKey)(uncompressedPubkey))).toBeTruthy();
    });
  });
  describe("getFingerprintFromPublicKey", function () {
    it("derives the correct fingerprint from a given key", function () {
      var node = NODES["m/45'/0'/0'/0"];
      var parentNode = NODES["m/45'/0'/0'"];
      var fingerprint = (0, _keys.getFingerprintFromPublicKey)(parentNode.pub);

      var decodedXpub = _bs.default.decode(node.xpub).toString("hex"); // the child node should have its parent's fingerprint in the xpub


      expect(node.parentFingerprint).toEqual(fingerprint); // we should also be able to find the fingerprint in the decoded xpub

      expect(decodedXpub).toContain(fingerprint.toString(16));
    });
  });
  describe("deriveExtendedPublicKey", function () {
    it("derives a valid bip32 node with all matching HD wallet properties", function () {
      var paths = ["m/45'/0'/0'", "m/45'/0'/0'/0"];

      for (var _i = 0, _paths = paths; _i < _paths.length; _i++) {
        var path = _paths[_i];
        var _NODES$path = NODES[path],
            parentFingerprint = _NODES$path.parentFingerprint,
            chaincode = _NODES$path.chaincode,
            xpub = _NODES$path.xpub,
            pub = _NODES$path.pub,
            tpub = _NODES$path.tpub;
        var derivedXpub = (0, _keys.deriveExtendedPublicKey)(path, pub, chaincode, parentFingerprint, _networks.MAINNET);
        var derivedTpub = (0, _keys.deriveExtendedPublicKey)(path, pub, chaincode, parentFingerprint, _networks.TESTNET);
        expect(derivedXpub).toEqual(xpub);
        expect(derivedTpub).toEqual(tpub);
      }
    });
  });
  describe("ExtendedPublicKey", function () {
    it("encodes and decodes an extended public key", function () {
      var paths = ["m/45'/0'/0'", "m/45'/0'/0'/0"];

      for (var _i2 = 0, _paths2 = paths; _i2 < _paths2.length; _i2++) {
        var path = _paths2[_i2];
        var _NODES$path2 = NODES[path],
            parentFingerprint = _NODES$path2.parentFingerprint,
            chaincode = _NODES$path2.chaincode,
            xpub = _NODES$path2.xpub,
            pubkey = _NODES$path2.pub,
            tpub = _NODES$path2.tpub;
        var extendedPubkey = new _keys.ExtendedPublicKey({
          path: path,
          pubkey: pubkey,
          chaincode: chaincode,
          parentFingerprint: parentFingerprint
        });
        expect(extendedPubkey.toBase58()).toEqual(xpub);
        extendedPubkey.setNetwork(_networks.TESTNET);
        expect(extendedPubkey.toBase58()).toEqual(tpub); // test fromBase58

        expect(_keys.ExtendedPublicKey.fromBase58(xpub).toBase58()).toEqual(xpub);
        expect(_keys.ExtendedPublicKey.fromBase58(tpub).toBase58()).toEqual(tpub); // test decoding (same as fromBase58)

        var decodedXpub = _keys.ExtendedPublicKey.decode(_bs58check.default.decode(xpub));

        var decodedTestnetXpub = _keys.ExtendedPublicKey.decode(_bs58check.default.decode(tpub));

        expect(decodedXpub.version).toEqual(_keys.EXTENDED_PUBLIC_KEY_VERSIONS.xpub);
        expect(decodedTestnetXpub.version).toEqual(_keys.EXTENDED_PUBLIC_KEY_VERSIONS.tpub);
        expect(decodedXpub.parentFingerprint).toEqual(parentFingerprint);
        expect(decodedTestnetXpub.parentFingerprint).toEqual(parentFingerprint);
        expect(decodedXpub.pubkey).toEqual(pubkey);
        expect(decodedTestnetXpub.pubkey).toEqual(pubkey);
        expect(decodedTestnetXpub.chaincode).toEqual(chaincode);
        expect(decodedTestnetXpub.chaincode).toEqual(chaincode);
      }
    });
  });
});