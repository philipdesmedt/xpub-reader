"use strict";

var _outputs = require("./outputs");

var _networks = require("./networks");

describe("outputs", function () {
  var validAddress = "2NE1LH35XT4YrdnEebk5oKMmRpGiYcUvpNR";
  describe('validateOutputs', function () {
    it("should return an error message if one of the outputs is invalid", function () {
      expect((0, _outputs.validateOutputs)(_networks.TESTNET, [{
        address: validAddress,
        amountSats: 1000
      }, {
        address: "foo",
        amountSats: 1000
      }])).toMatch(/invalid.+address/i);
    });
    it("should return an empty string if all outputs are valid", function () {
      expect((0, _outputs.validateOutputs)(_networks.TESTNET, [{
        address: validAddress,
        amountSats: 1000
      }])).toEqual("");
    });
  });
  describe('validateOutput', function () {
    it("should return an error message for a missing amount", function () {
      expect((0, _outputs.validateOutput)(_networks.TESTNET, {
        address: validAddress
      })).toMatch(/does not have.+amountSats/i);
    });
    it("should return an error message for an invalid amount", function () {
      expect((0, _outputs.validateOutput)(_networks.TESTNET, {
        address: validAddress,
        amountSats: "foo"
      })).toMatch(/invalid output amount/i);
    });
    it("should return an error message for a missing address", function () {
      expect((0, _outputs.validateOutput)(_networks.TESTNET, {
        amountSats: 10000
      })).toMatch(/does not have.+address/i);
    });
    it("should return an error message for an invalid address", function () {
      expect((0, _outputs.validateOutput)(_networks.TESTNET, {
        amountSats: 10000,
        address: "foo"
      })).toMatch(/invalid.+address/i);
    });
    it("returns an empty string on a valid output", function () {
      expect((0, _outputs.validateOutput)(_networks.TESTNET, {
        amountSats: 10000,
        address: validAddress
      })).toEqual("");
    });
  });
  describe('validateOutputAmount', function () {
    it("should return an error message for an unparseable output amount", function () {
      expect((0, _outputs.validateOutputAmount)('foo')).toMatch(/invalid output amount/i);
    });
    it("should return an error message for a negative output amount", function () {
      expect((0, _outputs.validateOutputAmount)(-10000)).toMatch(/output amount must be positive/i);
    });
    it("should return an error message for a zero output amount", function () {
      expect((0, _outputs.validateOutputAmount)(0)).toMatch(/output amount must be positive/i);
    });
    it("should return an error message when the output is too small", function () {
      expect((0, _outputs.validateOutputAmount)(100)).toMatch(/output amount is too small/i);
    });
    it("should return an empty string on an acceptable amount", function () {
      expect((0, _outputs.validateOutputAmount)(100000)).toBe("");
    });
    describe("when also passing `inputTotalSats`", function () {
      it("should return an error message for an unparseable output amount", function () {
        expect((0, _outputs.validateOutputAmount)('foo', 100000)).toMatch(/invalid output amount/i);
      });
      it("should return an error message for a negative output amount", function () {
        expect((0, _outputs.validateOutputAmount)(-10000, 100000)).toMatch(/output amount must be positive/i);
      });
      it("should return an error message for a zero output amount", function () {
        expect((0, _outputs.validateOutputAmount)(0, 100000)).toMatch(/output amount must be positive/i);
      });
      it("should return an error message when the output is too small", function () {
        expect((0, _outputs.validateOutputAmount)(100, 100000)).toMatch(/output amount is too small/i);
      });
      it("should return an error message for an unparseable total input amount", function () {
        expect((0, _outputs.validateOutputAmount)(100000, 'foo')).toMatch(/invalid total input amount/i);
      });
      it("should return an error message for a negative total input amount", function () {
        expect((0, _outputs.validateOutputAmount)(100000, -1000000)).toMatch(/total input amount must be positive/i);
      });
      it("should return an error message for a zero total input amount", function () {
        expect((0, _outputs.validateOutputAmount)(100000, 0)).toMatch(/total input amount must be positive/i);
      });
      it("should return an error message when the output is larger than the total input amount", function () {
        expect((0, _outputs.validateOutputAmount)(100001, 100000)).toMatch(/output amount is too large/i);
      });
      it("should return an empty string on an acceptable amount", function () {
        expect((0, _outputs.validateOutputAmount)(100000, 1000000)).toBe("");
      });
    });
  });
});