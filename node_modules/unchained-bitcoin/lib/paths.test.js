"use strict";

var _paths = require("./paths");

var _p2sh = require("./p2sh");

var _p2sh_p2wsh = require("./p2sh_p2wsh");

var _p2wsh = require("./p2wsh");

var _networks = require("./networks");

describe('paths', function () {
  describe('hardenedBIP32Index', function () {
    it("returns the hardened version of the given index", function () {
      expect((0, _paths.hardenedBIP32Index)('0')).toEqual(2147483648);
      expect((0, _paths.hardenedBIP32Index)('44')).toEqual(2147483692);
    });
  });
  describe('bip32PathToSequence', function () {
    it("converts a path to a sequence, including hardening", function () {
      expect((0, _paths.bip32PathToSequence)("m/45'/1/99")).toEqual([2147483693, 1, 99]);
    });
    it("assumes the path includes the prefix 'm/'", function () {
      expect((0, _paths.bip32PathToSequence)("45'/1/99")).toEqual([1, 99]);
    });
    it("returns an empty sequence on empty input", function () {
      expect((0, _paths.bip32PathToSequence)("")).toEqual([]);
      expect((0, _paths.bip32PathToSequence)("m")).toEqual([]);
    });
  });
  describe('bip32SequenceToPath', function () {
    it("converts a sequence to a path, including hardening", function () {
      expect((0, _paths.bip32SequenceToPath)([2147483693, 1, 99])).toBe("m/45'/1/99");
    });
    it("returns an empty path on empty input", function () {
      expect((0, _paths.bip32SequenceToPath)([])).toBe("m/");
    });
  });
  describe('validateBIP32Path', function () {
    it("returns an error message on invalid paths", function () {
      expect((0, _paths.validateBIP32Path)("")).toMatch(/cannot be blank/i);
      expect((0, _paths.validateBIP32Path)("foo")).toMatch(/is invalid/i);
      expect((0, _paths.validateBIP32Path)("/45")).toMatch(/is invalid/i);
      expect((0, _paths.validateBIP32Path)("m//45")).toMatch(/is invalid/i);
      expect((0, _paths.validateBIP32Path)("m/45''")).toMatch(/is invalid/i);
      expect((0, _paths.validateBIP32Path)("m/-45")).toMatch(/is invalid/i);
      expect((0, _paths.validateBIP32Path)("m/4.5")).toMatch(/is invalid/i);
      expect((0, _paths.validateBIP32Path)("m/4f")).toMatch(/is invalid/i);
    });
    it("returns an error message when a derivation index is too high", function () {
      expect((0, _paths.validateBIP32Path)("m/4294967296")).toMatch(/index is too high/i);
      expect((0, _paths.validateBIP32Path)("m/45'/2147483648'/0")).toMatch(/index is too high/i);
    });
    it("returns an empty string on valid paths", function () {
      expect((0, _paths.validateBIP32Path)("m/45")).toEqual("");
      expect((0, _paths.validateBIP32Path)("m/45'")).toEqual("");
      expect((0, _paths.validateBIP32Path)("m/45/0")).toEqual("");
      expect((0, _paths.validateBIP32Path)("m/44'/0'")).toEqual("");
      expect((0, _paths.validateBIP32Path)("m/45'/0'/0'/0/0")).toEqual("");
      expect((0, _paths.validateBIP32Path)("m/448/1'/1'/23/45638")).toEqual("");
    });
    it("enforces mode=hardened if asked", function () {
      expect((0, _paths.validateBIP32Path)("m/45'/0")).toEqual("");
      expect((0, _paths.validateBIP32Path)("m/45'/0", {
        mode: "hardened"
      })).toMatch(/fully-hardened/i);
    });
    it("enforces mode=unhardened if asked", function () {
      expect((0, _paths.validateBIP32Path)("m/45'/0")).toEqual("");
      expect((0, _paths.validateBIP32Path)("m/45'/0", {
        mode: "unhardened"
      })).toMatch(/cannot include hardened/i);
    });
  });
  describe('validateBIP32Index', function () {
    it("returns an error message on invalid indices", function () {
      expect((0, _paths.validateBIP32Index)("")).toMatch(/cannot be blank/i);
      expect((0, _paths.validateBIP32Index)("foo")).toMatch(/is invalid/i);
      expect((0, _paths.validateBIP32Index)("/45")).toMatch(/is invalid/i);
      expect((0, _paths.validateBIP32Index)("m//45")).toMatch(/is invalid/i);
      expect((0, _paths.validateBIP32Index)("m/45''")).toMatch(/is invalid/i);
      expect((0, _paths.validateBIP32Index)("m/-45")).toMatch(/is invalid/i);
      expect((0, _paths.validateBIP32Index)("m/4.5")).toMatch(/is invalid/i);
      expect((0, _paths.validateBIP32Index)("m/4f")).toMatch(/is invalid/i);
      expect((0, _paths.validateBIP32Index)("m/45/0")).toMatch(/is invalid/i);
      expect((0, _paths.validateBIP32Index)("m/44'/0'")).toMatch(/is invalid/i);
      expect((0, _paths.validateBIP32Index)("-45")).toMatch(/is invalid/i);
      expect((0, _paths.validateBIP32Index)("-0")).toMatch(/is invalid/i);
    });
    it("returns an error message when the index is too high", function () {
      expect((0, _paths.validateBIP32Index)("85899345929999999999999999999999999999")).toMatch(/Invalid BIP32 index/i);
      expect((0, _paths.validateBIP32Index)("4294967296")).toMatch(/index is too high/i);
      expect((0, _paths.validateBIP32Index)("2147483648'")).toMatch(/index is too high/i);
    });
    it("returns an empty string on valid paths", function () {
      expect((0, _paths.validateBIP32Index)("45")).toEqual("");
      expect((0, _paths.validateBIP32Index)("45'")).toEqual("");
      expect((0, _paths.validateBIP32Index)("0")).toEqual("");
      expect((0, _paths.validateBIP32Index)("0'")).toEqual("");
      expect((0, _paths.validateBIP32Index)("4294967295")).toEqual("");
      expect((0, _paths.validateBIP32Index)("2147483647")).toEqual("");
      expect((0, _paths.validateBIP32Index)("2147483647'")).toEqual("");
    });
    it("enforces mode=hardened if asked", function () {
      expect((0, _paths.validateBIP32Index)("45'")).toEqual("");
      expect((0, _paths.validateBIP32Index)("45")).toEqual("");
      expect((0, _paths.validateBIP32Index)("45'", {
        mode: "hardened"
      })).toEqual("");
      expect((0, _paths.validateBIP32Index)("2147483648", {
        mode: "hardened"
      })).toEqual("");
      expect((0, _paths.validateBIP32Index)("45", {
        mode: "hardened"
      })).toMatch(/must be hardened/i);
    });
    it("enforces mode=unhardened if asked", function () {
      expect((0, _paths.validateBIP32Index)("45'")).toEqual("");
      expect((0, _paths.validateBIP32Index)("45")).toEqual("");
      expect((0, _paths.validateBIP32Index)("45", {
        mode: "unhardened"
      })).toEqual("");
      expect((0, _paths.validateBIP32Index)("45'", {
        mode: "unhardened"
      })).toMatch(/cannot be hardened/i);
      expect((0, _paths.validateBIP32Index)("2147483648", {
        mode: "unhardened"
      })).toMatch(/cannot be hardened/i);
    });
  });
  describe('multisigBIP32Root', function () {
    it("returns the correct root BIP32 path for each combination of address type and network", function () {
      expect((0, _paths.multisigBIP32Root)(_p2sh.P2SH, _networks.MAINNET)).toEqual("m/45'/0'/0'");
      expect((0, _paths.multisigBIP32Root)(_p2sh.P2SH, _networks.TESTNET)).toEqual("m/45'/1'/0'");
      expect((0, _paths.multisigBIP32Root)(_p2sh_p2wsh.P2SH_P2WSH, _networks.MAINNET)).toEqual("m/48'/0'/0'/1'");
      expect((0, _paths.multisigBIP32Root)(_p2sh_p2wsh.P2SH_P2WSH, _networks.TESTNET)).toEqual("m/48'/1'/0'/1'");
      expect((0, _paths.multisigBIP32Root)(_p2wsh.P2WSH, _networks.MAINNET)).toEqual("m/48'/0'/0'/2'");
      expect((0, _paths.multisigBIP32Root)(_p2wsh.P2WSH, _networks.TESTNET)).toEqual("m/48'/1'/0'/2'");
    });
    it("defaults to testnet for invalid networks", function () {
      expect((0, _paths.multisigBIP32Root)(_p2sh.P2SH, "foobar")).toEqual("m/45'/1'/0'");
      expect((0, _paths.multisigBIP32Root)(_p2sh_p2wsh.P2SH_P2WSH, "foobar")).toEqual("m/48'/1'/0'/1'");
      expect((0, _paths.multisigBIP32Root)(_p2wsh.P2WSH, "foobar")).toEqual("m/48'/1'/0'/2'");
    });
    it("returns null for invalid address types", function () {
      expect((0, _paths.multisigBIP32Root)("foobar", _networks.MAINNET)).toBeNull();
      expect((0, _paths.multisigBIP32Root)("foobar", _networks.TESTNET)).toBeNull();
    });
  });
  describe('multisigBIP32Path', function () {
    it("returns a BIP32 path with the correct root for each combination of address type, network, and relative path", function () {
      expect((0, _paths.multisigBIP32Path)(_p2sh.P2SH, _networks.MAINNET, "1")).toEqual("m/45'/0'/0'/1");
      expect((0, _paths.multisigBIP32Path)(_p2sh.P2SH, _networks.TESTNET, "1'/2'")).toEqual("m/45'/1'/0'/1'/2'");
      expect((0, _paths.multisigBIP32Path)(_p2sh_p2wsh.P2SH_P2WSH, _networks.MAINNET, 0)).toEqual("m/48'/0'/0'/1'/0");
      expect((0, _paths.multisigBIP32Path)(_p2wsh.P2WSH, _networks.TESTNET, 3)).toEqual("m/48'/1'/0'/2'/3");
    });
    it("defaults to the relative path 0", function () {
      expect((0, _paths.multisigBIP32Path)(_p2sh.P2SH, _networks.MAINNET)).toEqual("m/45'/0'/0'/0");
      expect((0, _paths.multisigBIP32Path)(_p2sh.P2SH, _networks.TESTNET)).toEqual("m/45'/1'/0'/0");
    });
  });
  describe('getParentPath', function () {
    it("validates and returns the correct BIP32 parent path for each given path", function () {
      expect((0, _paths.getParentPath)("")).toMatch(/cannot be blank/i);
      expect((0, _paths.getParentPath)("foo")).toMatch(/is invalid/i);
      expect((0, _paths.getParentPath)("/45")).toMatch(/is invalid/i);
      var validPaths = ["m/45'", "m/45'/0'", "m/45'/0'/0'", "m/45'/0'/0'/0", "m/45'/0'/0'/0/0"];

      for (var i = validPaths.length - 1; i > 0; i--) {
        var expected = validPaths[i - 1];
        var actual = (0, _paths.getParentPath)(validPaths[i]);
        expect(actual).toMatch(expected);
      }
    });
  });
});