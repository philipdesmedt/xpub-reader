"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateMultisigSignature = validateMultisigSignature;
exports.signatureNoSighashType = signatureNoSighashType;

var _bignumber = _interopRequireDefault(require("bignumber.js"));

var _bip = _interopRequireDefault(require("bip66"));

var _p2sh_p2wsh = require("./p2sh_p2wsh");

var _p2wsh = require("./p2wsh");

var _multisig = require("./multisig");

var _transactions = require("./transactions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This modulde provides functions for validating and handling
 * multisig transaction signatures.
 * 
 * @module signatures
 */
var bitcoin = require('bitcoinjs-lib');
/**
 * Validate a multisig signature for given input and public key.
 * 
 * @param {module:networks.NETWORKS} network - bitcoin network
 * @param {module:inputs.MultisigTransactionInput[]} inputs - multisig transaction inputs
 * @param {module:outputs.TransactionOutput[]} outputs - transaction outputs
 * @param {number} inputIndex - the index where the input appears in the transaction
 * @param {string} inputSignature - signature to validate
 * @returns {string|boolean} false if invalid or corresponding public key
 * @example
 * import {
 *   generateMultisigFromPublicKeys, TESTNET, P2SH,
 *   unsignedMultisigTransaction,
 *   validateMultisigSignature,
 * } from "unchained-bitcoin";
 * const pubkey1 = "03a...";
 * const pubkey2 = "03b...";
 * const multisig = generateMultisigFromPublicKeys(TESTNET, P2SH, 2, pubkey1, pubkey2);
 * const inputs = [
 *   {
 *     txid: "ae...",
 *     index: 0,
 *     multisig,
 *   },
 *   // other inputs...
 * ];
 * const outputs = [
 *   {
 *     address: "2N...",
 *     amountSats: 90000,
 *   },
 *   // other outputs...
 * ];
 * const unsignedTransaction = unsignedMultisigTransaction(TESTNET, inputs, outputs);
 * // Use unsignedTransaction to obtain a signature.
 * const transactionSignature = ["304...", // other input signatures...];
 * // Validate signature for input 0
 * const result = validateMultisigSignature(TESTNET, inputs, outputs, 0, transactionSignature[0]);
 * switch (result) {
 *   case false:
 *     // signature was invalid
 *   case pubkey1:
 *     // signature was valid for pubkey1
 *   case pubkey2:
 *     // signature was valid for pubkey2
 *   default:
 *     // ...
 * }
 */


function validateMultisigSignature(network, inputs, outputs, inputIndex, inputSignature) {
  var hash = multisigSignatureHash(network, inputs, outputs, inputIndex);
  var signatureBuffer = multisigSignatureBuffer(signatureNoSighashType(inputSignature));
  var input = inputs[inputIndex];
  var publicKeys = (0, _multisig.multisigPublicKeys)(input.multisig);

  for (var publicKeyIndex = 0; publicKeyIndex < (0, _multisig.multisigTotalSigners)(input.multisig); publicKeyIndex++) {
    var publicKey = publicKeys[publicKeyIndex];
    var publicKeyBuffer = Buffer.from(publicKey, 'hex');
    var keyPair = bitcoin.ECPair.fromPublicKey(publicKeyBuffer);

    if (keyPair.verify(hash, signatureBuffer)) {
      return publicKey;
    }
  }

  return false;
}

function signatureNoSighashType(signature) {
  var len = parseInt(signature.slice(2, 4), 16);
  if (len == (signature.length - 4) / 2) return signature;else return signature.slice(0, -2);
}

function multisigSignatureHash(network, inputs, outputs, inputIndex) {
  var unsignedTransaction = (0, _transactions.unsignedMultisigTransaction)(network, inputs, outputs);
  var input = inputs[inputIndex];

  if ((0, _multisig.multisigAddressType)(input.multisig) === _p2wsh.P2WSH || (0, _multisig.multisigAddressType)(input.multisig) === _p2sh_p2wsh.P2SH_P2WSH) {
    return unsignedTransaction.hashForWitnessV0(inputIndex, (0, _multisig.multisigWitnessScript)(input.multisig).output, (0, _bignumber.default)(input.amountSats).toNumber(), bitcoin.Transaction.SIGHASH_ALL);
  } else {
    return unsignedTransaction.hashForSignature(inputIndex, (0, _multisig.multisigRedeemScript)(input.multisig).output, bitcoin.Transaction.SIGHASH_ALL);
  }
}

function multisigSignatureBuffer(signature) {
  var encodedSignerInputSignatureBuffer = Buffer.from(signature, 'hex');

  var decodedSignerInputSignatureBuffer = _bip.default.decode(encodedSignerInputSignatureBuffer);

  var r = decodedSignerInputSignatureBuffer.r,
      s = decodedSignerInputSignatureBuffer.s; // Ignore the leading 0 if r is 33 bytes

  var rToUse = r;

  if (r.byteLength > 32) {
    rToUse = r.slice(1);
  }

  var signatureBuffer = Buffer.alloc(64);
  signatureBuffer.set(Buffer.from(rToUse), 0);
  signatureBuffer.set(Buffer.from(s), 32);
  return signatureBuffer;
}