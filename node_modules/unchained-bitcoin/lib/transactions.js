"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unsignedMultisigTransaction = unsignedMultisigTransaction;
exports.signedMultisigTransaction = signedMultisigTransaction;

require("core-js/modules/es6.string.iterator");

require("core-js/modules/es6.array.from");

require("core-js/modules/es6.regexp.to-string");

require("core-js/modules/es6.object.to-string");

require("core-js/modules/es7.symbol.async-iterator");

require("core-js/modules/es6.symbol");

require("core-js/modules/web.dom.iterable");

var _bignumber = _interopRequireDefault(require("bignumber.js"));

var _networks = require("./networks");

var _p2sh_p2wsh = require("./p2sh_p2wsh");

var _p2wsh = require("./p2wsh");

var _multisig = require("./multisig");

var _signatures = require("./signatures");

var _inputs = require("./inputs");

var _outputs = require("./outputs");

var _script = require("./script");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var bitcoin = require('bitcoinjs-lib');
/**
 * Create an unsigned bitcoin transaction based on the network, inputs
 * and outputs.
 *
 * Returns a [`Transaction`]{@link https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/types/transaction.d.ts|Transaction} object from bitcoinjs-lib.
 *
 * @param {module:networks.NETWORKS} network - bitcoin network
 * @param {module:inputs.MultisigTransactionInput[]} inputs - transaction inputs
 * @param {module:outputs.TransactionOutput[]} outputs - transaction outputs
 * @returns {Transaction} an unsigned bitcoinjs-lib Transaction object
 * @example
 * import {
 *   generateMultisigFromPublicKeys, TESTNET, P2SH,
 *   unsignedMultisigTransaction,
 * } from "unchained-bitcoin";
 * const multisig = generateMultisigFromPublicKeys(TESTNET, P2SH, 2, "03a...", "03b...");
 * const inputs = [
 *   {
 *     txid: "ae...",
 *     index: 0,
 *     multisig,
 *   },
 *   // other inputs...
 * ];
 * const outputs = [
 *   {
 *     address: "2N...",
 *     amountSats: 90000,
 *   },
 *   // other outputs...
 * ];
 * const unsignedTransaction = unsignedMultisigTransaction(TESTNET, inputs, outputs);
 * 
 */


function unsignedMultisigTransaction(network, inputs, outputs) {
  var error = (0, _inputs.validateMultisigInputs)(inputs);

  if (error) {
    throw new Error(error);
  }

  error = (0, _outputs.validateOutputs)(network, outputs);

  if (error) {
    throw new Error(error);
  }

  var transactionBuilder = new bitcoin.TransactionBuilder();
  transactionBuilder.setVersion(1); // FIXME this depends on type...

  transactionBuilder.network = (0, _networks.networkData)(network);

  for (var inputIndex = 0; inputIndex < inputs.length; inputIndex += 1) {
    var input = inputs[inputIndex];
    transactionBuilder.addInput(input.txid, input.index);
  }

  for (var outputIndex = 0; outputIndex < outputs.length; outputIndex += 1) {
    var output = outputs[outputIndex];
    transactionBuilder.addOutput(output.address, (0, _bignumber.default)(output.amountSats).toNumber());
  }

  return transactionBuilder.buildIncomplete();
}
/**
 * Create a fully signed multisig transaction based on the unsigned
 * transaction, inputs, and their signatures.
 * 
 * @param {module:networks.NETWORKS} network - bitcoin network
 * @param {module:inputs.MultisigTransactionInput[]} inputs - multisig transaction inputs
 * @param {module:outputs.TransactionOutput[]} outputs - transaction outputs
 * @param {Object[]} transactionSignatures - array of transaction signatures, each an array of input signatures (1 per input)
 * @returns {Transaction} a signed {@link https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/types/transaction.d.ts|Transaction} object
 * @example
 * import {
 *   generateMultisigFromPublicKeys, TESTNET, P2SH,
 *   signedMultisigTransaction,
 * } from "unchained-bitcoin";
 * const pubkey1 = "03a...";
 * const pubkey2 = "03b...";
 * const multisig = generateMultisigFromPublicKeys(TESTNET, P2SH, 2, pubkey1, pubkey2);
 * const inputs = [
 *   {
 *     txid: "ae...",
 *     index: 0,
 *     multisig,
 *   },
 *   // other inputs...
 * ];
 * const outputs = [
 *   {
 *     address: "2N...",
 *     amountSats: 90000,
 *   },
 *   // other outputs...
 * ];
 * const transactionSignatures = [
 *   // Each element is an array of signatures from a given key, one per input.
 *   [
 *     "301a...",
 *     // more, 1 per input
 *   ],
 *   [
 *     "301b...",
 *     // more, 1 per input
 *   ],
 *   // More transaction signatures if required, based on inputs
 * ];
 * const signedTransaction = signedMultisigTransaction(TESTNET, inputs, outputs, transactionSignatures)
 */


function signedMultisigTransaction(network, inputs, outputs, transactionSignatures) {
  var unsignedTransaction = unsignedMultisigTransaction(network, inputs, outputs); // validates inputs & outputs

  if (!transactionSignatures || transactionSignatures.length === 0) {
    throw new Error("At least one transaction signature is required.");
  }

  transactionSignatures.forEach(function (transactionSignature, transactionSignatureIndex) {
    if (transactionSignature.length < inputs.length) {
      throw new Error("Insufficient input signatures for transaction signature ".concat(transactionSignatureIndex + 1, ": require ").concat(inputs.length, ", received ").concat(transactionSignature.length, "."));
    }
  });
  var signedTransaction = bitcoin.Transaction.fromHex(unsignedTransaction.toHex()); // FIXME inefficient?

  var _loop = function _loop(inputIndex) {
    var input = inputs[inputIndex];
    var inputSignatures = transactionSignatures.map(function (transactionSignature) {
      return transactionSignature[inputIndex];
    }).filter(function (inputSignature) {
      return Boolean(inputSignature);
    });
    var requiredSignatures = (0, _multisig.multisigRequiredSigners)(input.multisig);

    if (inputSignatures.length < requiredSignatures) {
      throw new Error("Insufficient signatures for input  ".concat(inputIndex + 1, ": require ").concat(requiredSignatures, ",  received ").concat(inputSignatures.length, "."));
    }

    var inputSignaturesByPublicKey = {};
    inputSignatures.forEach(function (inputSignature) {
      var publicKey;

      try {
        publicKey = (0, _signatures.validateMultisigSignature)(network, inputs, outputs, inputIndex, inputSignature);
      } catch (e) {
        throw new Error("Invalid signature for input ".concat(inputIndex + 1, ": ").concat(inputSignature, " (").concat(e, ")"));
      }

      if (!publicKey) {
        throw new Error("Invalid signature for input ".concat(inputIndex + 1, ": ").concat(inputSignature));
      }

      if (inputSignaturesByPublicKey[publicKey]) {
        throw new Error("Duplicate signature for input ".concat(inputIndex + 1, ": ").concat(inputSignature));
      }

      inputSignaturesByPublicKey[publicKey] = inputSignature;
    }); // Sort the signatures for this input by the index of their
    // corresponding public key within this input's redeem script.

    var publicKeys = (0, _multisig.multisigPublicKeys)(input.multisig);
    var sortedSignatures = publicKeys.map(function (publicKey) {
      return inputSignaturesByPublicKey[publicKey];
    }).filter(function (signature) {
      return signature ? (0, _signatures.signatureNoSighashType)(signature) : signature;
    }); // FIXME why not filter out the empty sigs?

    if ((0, _multisig.multisigAddressType)(input.multisig) === _p2wsh.P2WSH) {
      var witness = multisigWitnessField(input.multisig, sortedSignatures);
      signedTransaction.setWitness(inputIndex, witness);
    } else if ((0, _multisig.multisigAddressType)(input.multisig) === _p2sh_p2wsh.P2SH_P2WSH) {
      var _witness = multisigWitnessField(input.multisig, sortedSignatures);

      signedTransaction.setWitness(inputIndex, _witness);
      var scriptSig = (0, _multisig.multisigRedeemScript)(input.multisig);
      signedTransaction.ins[inputIndex].script = Buffer.from([scriptSig.output.length].concat(_toConsumableArray(scriptSig.output)));
    } else {
      var _scriptSig = multisigScriptSig(input.multisig, sortedSignatures);

      signedTransaction.ins[inputIndex].script = _scriptSig.input;
    }
  };

  for (var inputIndex = 0; inputIndex < inputs.length; inputIndex++) {
    _loop(inputIndex);
  }

  return signedTransaction;
}

function multisigWitnessField(multisig, sortedSignatures) {
  var witness = [""].concat(sortedSignatures.map(function (s) {
    return (0, _signatures.signatureNoSighashType)(s) + '01';
  }));
  var witnessScript = (0, _multisig.multisigWitnessScript)(multisig);
  witness.push((0, _script.scriptToHex)(witnessScript));
  return witness.map(function (wit) {
    return Buffer.from(wit, 'hex');
  });
}

function multisigScriptSig(multisig, signersInputSignatures) {
  var signatureOps = signersInputSignatures.map(function (signature) {
    return "".concat((0, _signatures.signatureNoSighashType)(signature), "01");
  }).join(' '); // 01 => SIGHASH_ALL

  var inputScript = "OP_0 ".concat(signatureOps);
  var inputScriptBuffer = bitcoin.script.fromASM(inputScript);
  var rawMultisig = bitcoin.payments.p2ms({
    network: multisig.network,
    output: Buffer.from((0, _multisig.multisigRedeemScript)(multisig).output, 'hex'),
    input: inputScriptBuffer
  });
  return (0, _multisig.generateMultisigFromRaw)((0, _multisig.multisigAddressType)(multisig), rawMultisig);
}