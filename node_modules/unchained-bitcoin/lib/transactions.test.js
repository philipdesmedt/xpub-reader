"use strict";

var _multisig = require("./multisig");

var _transactions = require("./transactions");

var _utils = require("./utils");

var _p2sh = require("./p2sh");

var _networks = require("./networks");

var _fixtures = require("./fixtures");

var bitcoin = require('bitcoinjs-lib');

describe("transactions", function () {
  describe("unsignedMultisigTransaction", function () {
    describe("validating arguments", function () {
      var fixture = _fixtures.TEST_FIXTURES.transactions[0];
      it("throws an error when there are no inputs", function () {
        expect(function () {
          (0, _transactions.unsignedMultisigTransaction)(fixture.network, [], fixture.outputs);
        }).toThrow(/at least one input/i);
      });
      it("throws an error when there an input is invalid", function () {
        expect(function () {
          (0, _transactions.unsignedMultisigTransaction)(fixture.network, [{}], fixture.outputs);
        }).toThrow(/does not have.*txid/i);
      });
      it("throws an error when there are no outputs", function () {
        expect(function () {
          (0, _transactions.unsignedMultisigTransaction)(fixture.network, fixture.inputs, []);
        }).toThrow(/at least one output/i);
      });
      it("throws an error when there an output is invalid", function () {
        expect(function () {
          (0, _transactions.unsignedMultisigTransaction)(fixture.network, fixture.inputs, [{}]);
        }).toThrow(/does not have.*amount/i);
      });
    });

    _fixtures.TEST_FIXTURES.transactions.forEach(function (fixture) {
      it("can construct an unsigned multisig transaction which ".concat(fixture.description), function () {
        var transaction = (0, _transactions.unsignedMultisigTransaction)(fixture.network, fixture.inputs, fixture.outputs);
        expect(transaction.ins.length).toEqual(fixture.inputs.length);
        expect(transaction.outs.length).toEqual(fixture.outputs.length);
        fixture.inputs.forEach(function (input, inputIndex) {
          expect(transaction.ins[inputIndex].index).toEqual(input.index); // TXIDs are displayed in reversed order

          var reversedTXIDBuffer = transaction.ins[inputIndex].hash; // Don't want to modify buffer in place so use Buffer.from

          expect((0, _utils.toHexString)(Buffer.from(reversedTXIDBuffer).reverse())).toEqual(input.txid);
        });
        fixture.outputs.forEach(function (output, outputIndex) {
          expect(transaction.outs[outputIndex].value).toEqual(output.amountSats.toNumber());
          expect(bitcoin.address.fromOutputScript(transaction.outs[outputIndex].script, (0, _networks.networkData)(fixture.network))).toEqual(output.address);
        });
        expect(transaction.toHex()).toEqual(fixture.hex);
      });
    });
  });
  describe("signedMultisigTransaction", function () {
    var fixture = _fixtures.TEST_FIXTURES.transactions[0];
    it("throws an error when there are no inputs", function () {
      expect(function () {
        (0, _transactions.signedMultisigTransaction)(fixture.network, [], fixture.outputs);
      }).toThrow(/at least one input/i);
    });
    it("throws an error when there an input is invalid", function () {
      expect(function () {
        (0, _transactions.signedMultisigTransaction)(fixture.network, [{}], fixture.outputs);
      }).toThrow(/does not have.*txid/i);
    });
    it("throws an error when there are no outputs", function () {
      expect(function () {
        (0, _transactions.signedMultisigTransaction)(fixture.network, fixture.inputs, []);
      }).toThrow(/at least one output/i);
    });
    it("throws an error when there an output is invalid", function () {
      expect(function () {
        (0, _transactions.signedMultisigTransaction)(fixture.network, fixture.inputs, [{}]);
      }).toThrow(/does not have.*amount/i);
    });
    it("throws an error when there are no transaction signatures", function () {
      expect(function () {
        (0, _transactions.signedMultisigTransaction)(fixture.network, fixture.inputs, fixture.outputs);
      }).toThrow(/at least one transaction signature/i);
      expect(function () {
        (0, _transactions.signedMultisigTransaction)(fixture.network, fixture.inputs, fixture.outputs, []);
      }).toThrow(/at least one transaction signature/i);
    });
    it("throws an error when there a transaction signature doesn't contain enough input signatures", function () {
      expect(function () {
        (0, _transactions.signedMultisigTransaction)(fixture.network, fixture.inputs, fixture.outputs, [[]]);
      }).toThrow(/insufficient input signatures/i);
      expect(function () {
        (0, _transactions.signedMultisigTransaction)(fixture.network, fixture.inputs, fixture.outputs, [fixture.signature, []]);
      }).toThrow(/insufficient input signatures/i);
    });
    it("throws an error when too few input signatures are given", function () {
      expect(function () {
        (0, _transactions.signedMultisigTransaction)(fixture.network, fixture.inputs, fixture.outputs, [fixture.signature]);
      }).toThrow(/insufficient signatures for input/i);
    });
    it("throws an error when an invalid input signature is given", function () {
      expect(function () {
        (0, _transactions.signedMultisigTransaction)(fixture.network, fixture.inputs, fixture.outputs, [fixture.signature, ["foo", "bar", "baz"]]);
      }).toThrow(/invalid signature for input/i);
    });
    it("throws an error when a duplicate input signature is given", function () {
      expect(function () {
        (0, _transactions.signedMultisigTransaction)(fixture.network, fixture.inputs, fixture.outputs, [fixture.signature, fixture.signature]);
      }).toThrow(/duplicate signature for input/i);
    });
    it("can construct a valid signed transaction", function () {
      var redeemScriptHex = "522103684f6787d61cc6af5ea660129f97e312ce0e5276abaf569e842f167c4630126021030c58cc16013c7fdf510ab2b68be808e0de2b25d0f36bb17c60bafd11bb052d9e21020cc7153dd76284f35f8caa86a7d1cae228b10f1bb94dcdbc34ce579b2ea08e1053ae";
      var multisig = (0, _multisig.generateMultisigFromHex)(_networks.TESTNET, _p2sh.P2SH, redeemScriptHex); // This transaction has already been broadcast as
      // 57a87bfa6283f0d0f50da5205c5392a7a0ba27a888164920983e7bdd9f716ca6,
      // but no matter.

      var inputs = [{
        txid: "916d6c481237dfa78beaf0d931095bf0ce66a9d3d92a8c62a0f187f39f673ed7",
        index: 1,
        multisig: multisig
      }];
      var outputs = [{
        address: "tb1quzdlt9ytvg8z7rprn08shrtucnnju5zhf7jlsf",
        amountSats: 100000
      }, {
        address: "tb1qf8xhpmszkvpkjnelq76up4hnfn8qep8406safy",
        amountSats: 999318
      }];
      var transactionSignature1 = ["30440220564e4623beaed42fb0302a2ee2e78e1e7cbee5ed256285b831450b70e8dbc2fa022018a29525a2deccbf397a4952d64a9b317bbd926d44418ec3f6cff4b2001b474c"];
      var transactionSignature2 = ["30440220707beb7625cb4b9925bbae2668d34d44de78879728e14bc40d0c84ea7947c9860220230dcbde54882b481e287d852d2545bb0d955af13984d06ff62ba4bd1de6cd59"];
      var signedTransactionHex = "0100000001d73e679ff387f1a0628c2ad9d3a966cef05b0931d9f0ea8ba7df3712486c6d9101000000fc004730440220564e4623beaed42fb0302a2ee2e78e1e7cbee5ed256285b831450b70e8dbc2fa022018a29525a2deccbf397a4952d64a9b317bbd926d44418ec3f6cff4b2001b474c014730440220707beb7625cb4b9925bbae2668d34d44de78879728e14bc40d0c84ea7947c9860220230dcbde54882b481e287d852d2545bb0d955af13984d06ff62ba4bd1de6cd59014c69522103684f6787d61cc6af5ea660129f97e312ce0e5276abaf569e842f167c4630126021030c58cc16013c7fdf510ab2b68be808e0de2b25d0f36bb17c60bafd11bb052d9e21020cc7153dd76284f35f8caa86a7d1cae228b10f1bb94dcdbc34ce579b2ea08e1053aeffffffff02a086010000000000160014e09bf5948b620e2f0c239bcf0b8d7cc4e72e5057963f0f000000000016001449cd70ee02b303694f3f07b5c0d6f34cce0c84f500000000";
      var signedTransaction = (0, _transactions.signedMultisigTransaction)(_networks.TESTNET, inputs, outputs, [transactionSignature1, transactionSignature2]);
      expect(signedTransaction.toHex()).toEqual(signedTransactionHex);
    });
  });
});