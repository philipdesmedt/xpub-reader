"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toHexString = toHexString;
exports.validateHex = validateHex;
exports.satoshisToBitcoins = satoshisToBitcoins;
exports.bitcoinsToSatoshis = bitcoinsToSatoshis;
exports.hash160 = hash160;
exports.ZERO = void 0;

require("core-js/modules/es6.regexp.to-string");

require("core-js/modules/es6.object.to-string");

var _bignumber = _interopRequireDefault(require("bignumber.js"));

var _bitcoinjsLib = _interopRequireDefault(require("bitcoinjs-lib"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This module provides conversion and validation functions for units
 * (Satoshis, BTC) and hex strings.
 * 
 * @module utils
 */

/**
 * Converts a byte array to its hex representation.
 * 
 * @param {number[]} byteArray - input byte array
 * @returns {string} hex representation of input array
 * 
 * @example
 * import {toHexString} from "unchained-bitcoin";
 * const hex = toHexString([255, 0, 15, 16, 31, 32]);
 * console.log(hex) // ff000f101f20
 * 
 */
function toHexString(byteArray) {
  return Array.prototype.map.call(byteArray, function (byte) {
    return ('0' + (byte & 0xFF).toString(16)).slice(-2);
  }).join('');
}
/**
 * Validate whether the given string is hex.
 *
 * - Valid hex consists of an even number of characters 'a-f`, `A-F`,
 *   or `0-9`.  This is case-insensitive.
 *
 * - The presence of the common prefix `0x` will make the input be
 *   considered invalid (because of the` `x`).
 * 
 * @param {string} inputString - string to validate
 * @returns {string} empty if valid or corresponding validation message if not
 * 
 * @example
 * import {validateHex} from "unchained-bitcoin";
 * console.log(validateHex('00112233gg')) // "Invalid hex: ..."
 * console.log(validateHex('0xdeadbeef')) // "Invalid hex: ..."
 * console.log(validateHex('deadbeef')) // ""
 * console.log(validateHex('DEADbeef')) // ""
 * 
 */


function validateHex(inputString) {
  if (inputString.length % 2) {
    return 'Invalid hex: odd-length string.';
  }

  var re = /^[0-9A-Fa-f]*$/;

  if (!re.test(inputString)) {
    return 'Invalid hex: only characters a-f, A-F and 0-9 allowed.';
  }

  return '';
}
/**
 * Convert a value in Satoshis to BTC.
 *
 * - Accepts both positive and negative input values.
 * - Rounds down (towards zero) input value to the nearest Satoshi.
 * 
 * @param {BigNumber|string|number} satoshis - value in Satoshis
 * @returns {BigNumber} value in BTC
 * 
 * @example
 * import {satoshisToBitcoins} from "unchained-bitcoin";
 * console.log(satoshisToBitcoins(123450000)); // 1.2345
 * console.log(satoshisToBitcoins('0.5')); // 0
 * console.log(satoshisToBitcoins('-100000000.5')); // -1.0
 * 
 */


function satoshisToBitcoins(satoshis) {
  var originalValue = (0, _bignumber.default)(satoshis);
  var roundedValue = originalValue.integerValue(_bignumber.default.ROUND_DOWN);
  return roundedValue.shiftedBy(-8);
}
/**
 * Convert a value in BTC to Satoshis.
 *
 * - Accepts both positive and negative input values.
 * - Rounds down output value to the nearest Satoshi.
 * 
 * @param {BigNumber|string|number} btc - value in BTC
 * @returns {BigNumber} value in satoshis
 * 
 * @example
 * import {bitcoinsToSatoshis} from "unchained-bitcoin";
 * console.log(bitcoinsToSatoshis(1.2345)); // 123450000
 * console.log(bitcoinsToSatoshis(-1.2345)); // -123450000
 */


function bitcoinsToSatoshis(btc) {
  return (0, _bignumber.default)(btc).shiftedBy(8).integerValue(_bignumber.default.ROUND_DOWN);
}

var ZERO = (0, _bignumber.default)(0);
/**
 * Given a buffer as a digest, pass through sha256 and ripemd160
 * hash functions. Returns the result
 * @param {Buffer} buf - buffer to get hash160 of
 * @returns {Buffer} hash160 of the given buffer
 */

exports.ZERO = ZERO;

function hash160(buf) {
  return _bitcoinjsLib.default.crypto.ripemd160(_bitcoinjsLib.default.crypto.sha256(buf));
}